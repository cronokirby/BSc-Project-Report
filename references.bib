
@book{hoffstein_introduction_2014,
	address = {New York},
	edition = {2},
	series = {Undergraduate {Texts} in {Mathematics}},
	title = {An {Introduction} to {Mathematical} {Cryptography}},
	isbn = {978-1-4939-1710-5},
	url = {https://www.springer.com/gp/book/9781493917105},
	abstract = {This self-contained introduction to modern cryptography emphasizes the mathematics behind the theory of public key cryptosystems and digital signature schemes. The book focuses on these key topics while developing the mathematical tools needed for the construction and security analysis of diverse cryptosystems. Only basic linear algebra is required of the reader; techniques from algebra, number theory, and probability are introduced and developed as required. This text provides an ideal introduction for mathematics and computer science students to the mathematical foundations of modern cryptography. The book includes an extensive bibliography and index; supplementary materials are available online.The book covers a variety of topics that are considered central to mathematical cryptography. Key topics include:classical cryptographic constructions, such as Diffie–Hellmann key exchange, discrete logarithm-based cryptosystems, the RSA cryptosystem, and digital signatures;fundamental mathematical tools for cryptography, including primality testing, factorization algorithms, probability theory, information theory, and collision algorithms;an in-depth treatment of important cryptographic innovations, such as elliptic curves, elliptic curve and pairing-based cryptography, lattices, lattice-based cryptography, and the NTRU cryptosystem.The second edition of An Introduction to Mathematical Cryptography includes a significant revision of the material on digital signatures, including an earlier introduction to RSA, Elgamal, and DSA signatures, and new material on lattice-based signatures and rejection sampling. Many sections have been rewritten or expanded for clarity, especially in the chapters on information theory, elliptic curves, and lattices, and the chapter of additional topics has been expanded to include sections on digital cash and homomorphic encryption. Numerous new exercises have been included.},
	language = {en},
	urldate = {2021-01-15},
	publisher = {Springer-Verlag},
	author = {Hoffstein, Jeffrey and Pipher, Jill and Silverman, Joseph H.},
	year = {2014},
	doi = {10.1007/978-1-4939-1711-2},
	keywords = {Cryptography, Math},
	file = {Snapshot:/home/lucas/archive/Zotero/storage/7SLFIPYL/9781493917105.html:text/html},
}

@inproceedings{erbsen_simple_2019,
	address = {San Francisco, CA, USA},
	title = {Simple {High}-{Level} {Code} for {Cryptographic} {Arithmetic} - {With} {Proofs}, {Without} {Compromises}},
	isbn = {978-1-5386-6660-9},
	url = {https://ieeexplore.ieee.org/document/8835346/},
	doi = {10.1109/SP.2019.00005},
	abstract = {We introduce a new approach for implementing cryptographic arithmetic in short high-level code with machinechecked proofs of functional correctness. We further demonstrate that simple partial evaluation is sufﬁcient to transform such initial code into the fastest-known C code, breaking the decadesold pattern that the only fast implementations are those whose instruction-level steps were written out by hand.},
	language = {en},
	urldate = {2021-01-15},
	booktitle = {2019 {IEEE} {Symposium} on {Security} and {Privacy} ({SP})},
	publisher = {IEEE},
	author = {Erbsen, Andres and Philipoom, Jade and Gross, Jason and Sloan, Robert and Chlipala, Adam},
	month = may,
	year = {2019},
	pages = {1202--1219},
	file = {Erbsen et al. - 2019 - Simple High-Level Code for Cryptographic Arithmeti.pdf:/home/lucas/archive/Zotero/storage/9FU4W9CK/Erbsen et al. - 2019 - Simple High-Level Code for Cryptographic Arithmeti.pdf:application/pdf},
}

@inproceedings{reparaz_dude_2017,
	address = {Lausanne, Switzerland},
	title = {Dude, is my code constant time?},
	isbn = {978-3-9815370-8-6},
	url = {http://ieeexplore.ieee.org/document/7927267/},
	doi = {10.23919/DATE.2017.7927267},
	abstract = {This paper introduces dudect: a tool to assess whether a piece of code runs in constant time or not on a given platform. We base our approach on leakage detection techniques, resulting in a very compact, easy to use and easy to maintain tool. Our methodology ﬁts in around 300 lines of C and runs on the target platform. The approach is substantially different from previous solutions. Contrary to others, our solution requires no modeling of hardware behavior. Our solution can be used in black-box testing, yet beneﬁts from implementation details if available. We show the effectiveness of our approach by detecting several variable-time cryptographic implementations. We place a prototype implementation of dudect in the public domain.},
	language = {en},
	urldate = {2021-01-20},
	booktitle = {Design, {Automation} \& {Test} in {Europe} {Conference} \& {Exhibition} ({DATE}), 2017},
	publisher = {IEEE},
	author = {Reparaz, Oscar and Balasch, Josep and Verbauwhede, Ingrid},
	month = mar,
	year = {2017},
	pages = {1697--1702},
	file = {Reparaz et al. - 2017 - Dude, is my code constant time.pdf:/home/lucas/archive/Zotero/storage/75QL2SZI/Reparaz et al. - 2017 - Dude, is my code constant time.pdf:application/pdf},
}

@article{kocher_timing_1996,
	title = {Timing {Attacks} on {Implementations} of {Diffie}-{Hellman}, {RSA}, {DSS}, and {Other} {Systems}},
	abstract = {By carefully measuring the amount of time required to perform private key operations, attackers may be able to nd xed Di eHellman exponents, factor RSA keys, and break other cryptosystems. Against a vulnerable system, the attack is computationally inexpensive and often requires only known ciphertext. Actual systems are potentially at risk, including cryptographic tokens, network-based cryptosystems, and other applications where attackers can make reasonably accurate timing measurements. Techniques for preventing the attack for RSA and Di e-Hellman are presented. Some cryptosystems will need to be revised to protect against the attack, and new protocols and algorithms may need to incorporate measures to prevent timing attacks.},
	language = {en},
	author = {Kocher, Paul C},
	year = {1996},
	keywords = {Cryptography, RSA, Constant Time},
	pages = {10},
	file = {Kocher - Timing Attacks on Implementations of Di e-Hellman,.pdf:/home/lucas/archive/Zotero/storage/FDG676JN/Kocher - Timing Attacks on Implementations of Di e-Hellman,.pdf:application/pdf},
}

@article{brumley_remote_2005,
	series = {Web {Security}},
	title = {Remote timing attacks are practical},
	volume = {48},
	issn = {1389-1286},
	url = {http://www.sciencedirect.com/science/article/pii/S1389128605000125},
	doi = {10.1016/j.comnet.2005.01.010},
	abstract = {Timing attacks are usually used to attack weak computing devices such as smartcards. We show that timing attacks apply to general software systems. Specifically, we devise a timing attack against OpenSSL. Our experiments show that we can extract private keys from an OpenSSL-based web server running on a machine in the local network. Our results demonstrate that timing attacks against network servers are practical and therefore security systems should defend against them.},
	language = {en},
	number = {5},
	urldate = {2021-01-20},
	journal = {Computer Networks},
	author = {Brumley, David and Boneh, Dan},
	month = aug,
	year = {2005},
	keywords = {RSA, Chinese remainder, Montgomery reductions, SSL, Timing attack},
	pages = {701--716},
	file = {Brumley and Boneh - Remote Timing Attacks are Practical.pdf:/home/lucas/archive/Zotero/storage/EWNSKTHB/Brumley and Boneh - Remote Timing Attacks are Practical.pdf:application/pdf;ScienceDirect Snapshot:/home/lucas/archive/Zotero/storage/2ASCGPNI/S1389128605000125.html:text/html},
}

@misc{pornin_bearssl_2020,
	title = {{BearSSL} - {Constant}-{Time} {Crypto}},
	url = {https://www.bearssl.org/constanttime.html},
	urldate = {2021-01-20},
	author = {Pornin, Thomas},
	year = {2020},
	file = {BearSSL - Constant-Time Crypto:/home/lucas/archive/Zotero/storage/EJP2L2P6/constanttime.html:text/html},
}

@misc{noauthor_bearssl_2020,
	title = {{BearSSL} - {Big} {Integer} {Design}},
	url = {https://www.bearssl.org/bigint.html},
	urldate = {2021-01-20},
	year = {2020},
	file = {BearSSL - Big Integer Design:/home/lucas/archive/Zotero/storage/N8XPAQL7/bigint.html:text/html},
}

@article{yarom_cachebleed_2017,
	title = {{CacheBleed}: {A} {Timing} {Attack} on {OpenSSL} {Constant} {Time} {RSA}},
	abstract = {The scatter-gather technique is a commonly-implemented approach to prevent cache-based timing attacks. In this paper we show that scatter-gather is not constant-time. We implement a cache timing attack against the scatter-gather implementation used in the modular exponentiation routine in OpenSSL version 1.0.2f. Our attack exploits cache-bank conﬂicts on the Sandy Bridge microarchitecture. We have tested the attack on an Intel Xeon E5-2430 processor. For 4096-bit RSA our attack can fully recover the private key after observing 16,000 decryptions.},
	language = {en},
	author = {Yarom, Yuval and Genkin, Daniel and Heninger, Nadia},
	year = {2017},
	pages = {21},
	file = {Yarom et al. - CacheBleed A Timing Attack on OpenSSL Constant Ti.pdf:/home/lucas/archive/Zotero/storage/X2UGXDMV/Yarom et al. - CacheBleed A Timing Attack on OpenSSL Constant Ti.pdf:application/pdf},
}

@article{weiser_big_2020,
	title = {Big {Numbers} – {Big} {Troubles}: {Systematically} {Analyzing} {Nonce} {Leakage} in ({EC}){DSA} {Implementations}},
	abstract = {Side-channel attacks exploiting (EC)DSA nonce leakage easily lead to full key recovery. Although (EC)DSA implementations have already been hardened against side-channel leakage using the constant-time paradigm, the long-standing cat-andmouse-game of attacks and patches continues. In particular, current code review is prone to miss less obvious side channels hidden deeply in the call stack. To solve this problem, a systematic study of nonce leakage is necessary. We present a systematic analysis of nonce leakage in cryptographic implementations. In particular, we expand DATA, an open-source side-channel analysis framework, to detect nonce leakage. Our analysis identiﬁed multiple unknown nonce leakage vulnerabilities across all essential computation steps involving nonces. Among others, we uncover inherent problems in Bignumber implementations that break claimed constant-time guarantees of (EC)DSA implementations if secrets are close to a word boundary. We found that lazy resizing of Bignumbers in OpenSSL and LibreSSL yields a highly accurate and easily exploitable side channel, which has been acknowledged with two CVEs. Surprisingly, we also found a tiny but expressive leakage in the constant-time scalar multiplication of OpenSSL and BoringSSL. Moreover, in the process of reporting and patching, we identiﬁed newly introduced leakage with the support of our tool, thus preventing another attack-patch cycle. We open-source our tool, together with an intuitive graphical user interface we developed.},
	language = {en},
	author = {Weiser, Samuel and Bodner, Lukas and Schrammel, David and Spreitzer, Raphael},
	year = {2020},
	pages = {19},
	file = {Weiser et al. - Big Numbers – Big Troubles Systematically Analyzi.pdf:/home/lucas/archive/Zotero/storage/FWS2QUXS/Weiser et al. - Big Numbers – Big Troubles Systematically Analyzi.pdf:application/pdf},
}

@incollection{lopez_exponent_2011,
	address = {Berlin, Heidelberg},
	title = {Exponent {Blinding} {Does} {Not} {Always} {Lift} ({Partial}) {Spa} {Resistance} to {Higher}-{Level} {Security}},
	volume = {6715},
	isbn = {978-3-642-21553-7 978-3-642-21554-4},
	url = {http://link.springer.com/10.1007/978-3-642-21554-4_5},
	language = {en},
	urldate = {2021-01-28},
	booktitle = {Applied {Cryptography} and {Network} {Security}},
	publisher = {Springer Berlin Heidelberg},
	author = {Schindler, Werner and Itoh, Kouichi},
	editor = {Lopez, Javier and Tsudik, Gene},
	year = {2011},
	doi = {10.1007/978-3-642-21554-4_5},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {73--90},
	file = {Full Text:/home/lucas/archive/Zotero/storage/UNWAUVLK/Schindler and Itoh - 2011 - Exponent Blinding Does Not Always Lift (Partial) S.pdf:application/pdf},
}

@article{cabrera_aldaya_cache-timing_2019,
	title = {Cache-{Timing} {Attacks} on {RSA} {Key} {Generation}},
	issn = {2569-2925},
	url = {https://tches.iacr.org/index.php/TCHES/article/view/8350},
	doi = {10.46586/tches.v2019.i4.213-242},
	abstract = {During the last decade, constant-time cryptographic software has quickly transitioned from an academic construct to a concrete security requirement for real-world libraries. Most of OpenSSL’s constant-time code paths are driven by cryptosystem implementations enabling a dedicated ﬂag at runtime. This process is perilous, with several examples emerging in the past few years of the ﬂag either not being set or software defects directly mishandling the ﬂag. In this work, we propose a methodology to analyze security-critical software for side-channel insecure code path traversal. Applying our methodology to OpenSSL, we identify three new code paths during RSA key generation that potentially leak critical algorithm state. Exploiting one of these leaks, we design, implement, and mount a single trace cache-timing attack on the GCD computation step. We overcome several hurdles in the process, including but not limited to: (1) granularity issues due to word-size operands to the GCD function; (2) bulk processing of desynchronized trace data; (3) non-trivial error rate during information extraction; and (4) limited high-conﬁdence information on the modulus factors. Formulating lattice problem instances after obtaining and processing this limited information, our attack achieves roughly a 27\% success rate for key recovery using the empirical data from 10K trials.},
	language = {en},
	urldate = {2021-02-11},
	journal = {IACR Transactions on Cryptographic Hardware and Embedded Systems},
	author = {Cabrera Aldaya, Alejandro and Pereida García, Cesar and Alvarez Tapia, Luis Manuel and Brumley, Billy Bob},
	month = aug,
	year = {2019},
	pages = {213--242},
	file = {Cabrera Aldaya et al. - 2019 - Cache-Timing Attacks on RSA Key Generation.pdf:/home/lucas/archive/Zotero/storage/GQ2CYSVJ/Cabrera Aldaya et al. - 2019 - Cache-Timing Attacks on RSA Key Generation.pdf:application/pdf},
}

@article{gueron_efficient_2012,
	title = {Efficient software implementations of modular exponentiation},
	volume = {2},
	issn = {2190-8508, 2190-8516},
	url = {http://link.springer.com/10.1007/s13389-012-0031-5},
	doi = {10.1007/s13389-012-0031-5},
	abstract = {RSA computations have a significant effect on the workloads of SSL/TLS servers, and therefore their software implementations on general purpose processors are an important target for optimization. We concentrate here on 512-bit modular exponentiation, used for 1024-bit RSA. We propose optimizations in two directions. At the primitives’ level, we study and improve the performance of an “Almost” Montgomery Multiplication. At the exponentiation level, we propose a method to reduce the cost of protecting the w-ary exponentiation algorithm against cache/timing side channel attacks. Together, these lead to an efficient software implementation of 512-bit modular exponentiation, which outperforms the currently fastest publicly available alternative. When measured on the latest x86-64 architecture, the 2nd Generation Intel® Core™ processor, our implementation is 43\% faster than that of the current version of OpenSSL (1.0.0d).},
	language = {en},
	number = {1},
	urldate = {2021-02-12},
	journal = {Journal of Cryptographic Engineering},
	author = {Gueron, Shay},
	month = may,
	year = {2012},
	pages = {31--43},
	file = {Gueron - 2012 - Efficient software implementations of modular expo.pdf:/home/lucas/archive/Zotero/storage/MI25PLVM/Gueron - 2012 - Efficient software implementations of modular expo.pdf:application/pdf},
}

@article{bos_constant_2014,
	title = {Constant time modular inversion},
	volume = {4},
	issn = {2190-8508, 2190-8516},
	url = {http://link.springer.com/10.1007/s13389-014-0084-8},
	doi = {10.1007/s13389-014-0084-8},
	abstract = {Simple power analysis is a common technique to attack software implementations, especially in the realm of public-key cryptography. An eﬀective countermeasure to protect an implementation is to ensure constant (worst-case) runtime. In this paper we show how to modify an algorithm by Kaliski to compute the Montgomery inverse such that it can compute both the classical and Montgomery modular inverse in constant time. We demonstrate the eﬀectiveness by comparing it to the approach based on Fermat’s little theorem as used in the current simple power analysis resistant implementations in cryptography. Our implementation on the popular 32-bit ARM platform highlights the practical beneﬁts of this algorithm.},
	language = {en},
	number = {4},
	urldate = {2021-03-11},
	journal = {Journal of Cryptographic Engineering},
	author = {Bos, Joppe W.},
	month = nov,
	year = {2014},
	pages = {275--281},
	file = {Bos - 2014 - Constant time modular inversion.pdf:/home/lucas/archive/Zotero/storage/INBA254U/Bos - 2014 - Constant time modular inversion.pdf:application/pdf},
}

@book{knuth_art_1997,
	address = {USA},
	title = {The art of computer programming, volume 2 (3rd ed.): seminumerical algorithms},
	isbn = {978-0-201-89684-8},
	shorttitle = {The art of computer programming, volume 2 (3rd ed.)},
	publisher = {Addison-Wesley Longman Publishing Co., Inc.},
	author = {Knuth, Donald E.},
	year = {1997},
}

@book{shoup_computational_2009,
	address = {USA},
	edition = {2},
	title = {A {Computational} {Introduction} to {Number} {Theory} and {Algebra}},
	isbn = {978-0-521-51644-0},
	abstract = {This introductory book emphasizes algorithms and applications, such as cryptography and error correcting codes, and is accessible to a broad audience. The presentation alternates between theory and applications in order to motivate and illustrate the mathematics. The mathematical coverage includes the basics of number theory, abstract algebra and discrete probability theory. This edition now includes over 150 new exercises, ranging from the routine to the challenging, that flesh out the material presented in the body of the text, and which further develop the theory and present new applications. The material has also been reorganized to improve clarity of exposition and presentation. Ideal as a textbook for introductory courses in number theory and algebra, especially those geared towards computer science students.},
	publisher = {Cambridge University Press},
	author = {Shoup, Victor},
	year = {2009},
}

@article{bernstein_fast_2019,
	title = {Fast constant-time gcd computation and modular inversion},
	issn = {2569-2925},
	url = {https://tches.iacr.org/index.php/TCHES/article/view/8298},
	doi = {10.46586/tches.v2019.i3.340-398},
	abstract = {This paper introduces streamlined constant-time variants of Euclid’s algorithm, both for polynomial inputs and for integer inputs. As concrete applications, this paper saves time in (1) modular inversion for Curve25519, which was previously believed to be handled much more eﬃciently by Fermat’s method, and (2) key generation for the ntruhrss701 and sntrup4591761 lattice-based cryptosystems.},
	language = {en},
	urldate = {2021-03-27},
	journal = {IACR Transactions on Cryptographic Hardware and Embedded Systems},
	author = {Bernstein, Daniel J. and Yang, Bo-Yin},
	month = may,
	year = {2019},
	pages = {340--398},
	file = {Bernstein and Yang - 2019 - Fast constant-time gcd computation and modular inv.pdf:/home/lucas/archive/Zotero/storage/G7LKVRJ7/Bernstein and Yang - 2019 - Fast constant-time gcd computation and modular inv.pdf:application/pdf},
}

@article{hars_modular_2006,
	title = {Modular {Inverse} {Algorithms} {Without} {Multiplications} for {Cryptographic} {Applications}},
	volume = {2006},
	doi = {10.1186/1687-3963-2006-032192},
	abstract = {Hardware and algorithmic optimization techniques are presented to the left-shift, right-shift, and the traditional Euclidean-modular inverse algorithms. Theoretical arguments and extensive simulations determined the resulting expected running time. On many computational platforms these turn out to be the fastest known algorithms for moderate operand lengths. They are based on variants of Euclidean-type extended GCD algorithms. On the considered computational platforms for operand lengths used in cryptography, the fastest presented modular inverse algorithms need about twice the time of modular multiplications, or even less. Consequently, in elliptic curve cryptography delaying modular divisions is slower (affine coordinates are the best) and the RSA and ElGamal cryptosystems can be accelerated.},
	journal = {EURASIP Journal on Embedded Systems},
	author = {Hars, Laszlo},
	month = jan,
	year = {2006},
	pages = {032192},
	file = {Full Text:/home/lucas/archive/Zotero/storage/SZZLPJSK/Hars - 2006 - Modular Inverse Algorithms Without Multiplications.pdf:application/pdf},
}

@incollection{goos_new_2003,
	address = {Berlin, Heidelberg},
	title = {New {Algorithm} for {Classical} {Modular} {Inverse}},
	volume = {2523},
	isbn = {978-3-540-00409-7 978-3-540-36400-9},
	url = {http://link.springer.com/10.1007/3-540-36400-5_6},
	abstract = {The Montgomery inverse is used in cryptography for the computation of modular inverse of b modulo a, where a is a prime. We analyse existing algorithms from the point of view of their hardware implementation. We propose a new, hardware-optimal algorithm for the calculation of the classical modular inverse. The left-shift binary algorithm is shown to naturally calculate the classical modular inverse in fewer operations than the algorithm derived from the Montgomery inverse.},
	language = {en},
	urldate = {2021-03-27},
	booktitle = {Cryptographic {Hardware} and {Embedded} {Systems} - {CHES} 2002},
	publisher = {Springer Berlin Heidelberg},
	author = {Lórencz, Róbert},
	editor = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan and Kaliski, Burton S. and Koç, çetin K. and Paar, Christof},
	year = {2003},
	doi = {10.1007/3-540-36400-5_6},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {57--70},
	file = {Lórencz - 2003 - New Algorithm for Classical Modular Inverse.pdf:/home/lucas/archive/Zotero/storage/2WDMW74D/Lórencz - 2003 - New Algorithm for Classical Modular Inverse.pdf:application/pdf},
}

@article{pornin_optimized_2020,
	title = {Optimized {Binary} {GCD} for {Modular} {Inversion}},
	abstract = {In this short note, we describe a practical optimization of the well-known extended binary GCD algorithm, for the purpose of computing modular inverses. The method is conceptually simple and is applicable to all odd moduli (including nonprime moduli). When implemented for inversion in the eld of integers modulo the prime − , on a recent x CPU (Co ee Lake core), we compute the inverse in cycles, with a fully constant-time implementation.},
	language = {en},
	author = {Pornin, Thomas},
	year = {2020},
	pages = {16},
	file = {Pornin - Optimized Binary GCD for Modular Inversion.pdf:/home/lucas/archive/Zotero/storage/XLV7JZBR/Pornin - Optimized Binary GCD for Modular Inversion.pdf:application/pdf},
}

@article{kaya_koc_analyzing_1996,
	title = {Analyzing and comparing {Montgomery} multiplication algorithms},
	volume = {16},
	issn = {02721732},
	url = {http://ieeexplore.ieee.org/document/502403/},
	doi = {10.1109/40.502403},
	abstract = {This paper discusses several Montgomery multiplication algorithms, two of which have been proposed before. We describe three additional algorithms, and analyze in detail the space and time requirements of all ve methods. These algorithms have been implemented in C and in assembler. The analyses and actual performance results indicate that the Coarsely Integrated Operand Scanning CIOS method, detailed in this paper, is the most e cient of all ve algorithms, at least for the general class of processor we considered. The Montgomery multiplication methods constitute the core of the modular exponentiation operation which is the most popular method used in public-key cryptography for encrypting and signing digital data.},
	language = {en},
	number = {3},
	urldate = {2021-03-30},
	journal = {IEEE Micro},
	author = {Kaya Koc, C. and Acar, T. and Kaliski, B.S.},
	month = jun,
	year = {1996},
	pages = {26--33},
	file = {Kaya Koc et al. - 1996 - Analyzing and comparing Montgomery multiplication .pdf:/home/lucas/archive/Zotero/storage/K9IJN3SF/Kaya Koc et al. - 1996 - Analyzing and comparing Montgomery multiplication .pdf:application/pdf},
}

@article{bernstein_cache-timing_2005,
	title = {Cache-timing attacks on {AES}},
	abstract = {This paper demonstrates complete AES key recovery from known-plaintext timings of a network server on another computer. This attack should be blamed on the AES design, not on the particular AES library used by the server; it is extremely diﬃcult to write constant-time high-speed AES software for common general-purpose computers. This paper discusses several of the obstacles in detail.},
	language = {en},
	author = {Bernstein, Daniel J},
	year = {2005},
	pages = {37},
	file = {Bernstein - Cache-timing attacks on AES.pdf:/home/lucas/archive/Zotero/storage/GP63FRK5/Bernstein - Cache-timing attacks on AES.pdf:application/pdf},
}

@incollection{hutchison_predicting_2006,
	address = {Berlin, Heidelberg},
	title = {Predicting {Secret} {Keys} {Via} {Branch} {Prediction}},
	volume = {4377},
	isbn = {978-3-540-69327-7 978-3-540-69328-4},
	url = {http://link.springer.com/10.1007/11967668_15},
	abstract = {This paper presents a new software side-channel attack — enabled by the branch prediction capability common to all modern high-performance CPUs. The penalty payed (extra clock cycles) for a mispredicted branch can be used for cryptanalysis of cryptographic primitives that employ a data-dependent program ﬂow. Analogous to the recently described cache-based side-channel attacks our attacks also allow an unprivileged process to attack other processes running in parallel on the same processor, despite sophisticated partitioning methods such as memory protection, sandboxing or even virtualization. We will discuss in detail several such attacks for the example of RSA, and experimentally show their applicability to real systems, such as OpenSSL and Linux. More speciﬁcally, we will present four diﬀerent types of attacks, which are all derived from the basic idea underlying our novel side-channel attack. Moreover, we also demonstrate the strength of the branch prediction side-channel attack by rendering the obvious countermeasure in this context (Montgomery Multiplication with dummy-reduction) as useless. Although the deeper consequences of the latter result make the task of writing an eﬃcient and secure modular expeonentiation (or scalar multiplication on an elliptic curve) a challenging task, we will eventually suggest some countermeasures to mitigate branch prediction side-channel attacks.},
	language = {en},
	urldate = {2021-04-04},
	booktitle = {Topics in {Cryptology} – {CT}-{RSA} 2007},
	publisher = {Springer Berlin Heidelberg},
	author = {Acıiçmez, Onur and Koç, Çetin Kaya and Seifert, Jean-Pierre},
	editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Abe, Masayuki},
	year = {2006},
	doi = {10.1007/11967668_15},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {225--242},
	file = {Acıiçmez et al. - 2006 - Predicting Secret Keys Via Branch Prediction.pdf:/home/lucas/archive/Zotero/storage/MWUXI3ZQ/Acıiçmez et al. - 2006 - Predicting Secret Keys Via Branch Prediction.pdf:application/pdf},
}

@inproceedings{grabher_cryptographic_2007,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Cryptographic {Side}-{Channels} from {Low}-{Power} {Cache} {Memory}},
	isbn = {978-3-540-77272-9},
	doi = {10.1007/978-3-540-77272-9_11},
	abstract = {To deliver real world cryptographic applications, we are increasingly reliant on security guarantees from both the underlying mathematics and physical implementation. The micro-processors that execute such applications are often designed with a focus on performance, area or power consumption. This strategy neglects physical security, a fact that has recently been exploited by a new breed of micro-architectural side-channel attacks. We introduce a new attack within this class which targets the use of low power cache memories. Although such caches offer an attractive compromise between performance and power consumption within mobile computing devices, we show that they permit attack where a more considered design strategy would not.},
	language = {en},
	booktitle = {Cryptography and {Coding}},
	publisher = {Springer},
	author = {Grabher, Philipp and Großschädl, Johann and Page, Daniel},
	editor = {Galbraith, Steven D.},
	year = {2007},
	keywords = {Branch Prediction, Cache Line, Cache Memory, Instruction Cache, Modular Exponentiation},
	pages = {170--184},
}

@book{page_theoretical_2002,
	title = {Theoretical {Use} of {Cache} {Memory} as a {Cryptanalytic} {Side}-{Channel}},
	abstract = {We expand on the idea, proposed by Kelsey et al. [14], of cache memory being  used as a side-channel which leaks information during the run of a cryptographic  algorithm. By using this side-channel, an attacker may be able to reveal or narrow  the possible values of secret information held on the target device. We describe  an attack which encrypts 2    chosen plaintexts on the target processor in order to  collect cache profiles and then performs around 2    computational steps to recover  the key. As well as describing and simulating the theoretical attack, we discuss  how hardware and algorithmic alterations can be used to defend against such techniques.},
	author = {Page, D.},
	year = {2002},
	file = {Citeseer - Full Text PDF:/home/lucas/archive/Zotero/storage/87SATJU2/Page - 2002 - Theoretical Use of Cache Memory as a Cryptanalytic.pdf:application/pdf},
}

@article{merget_raccoon_2019,
	title = {Raccoon {Attack}: {Finding} and {Exploiting} {Most}-{Signiﬁcant}-{Bit}-{Oracles} in},
	abstract = {Difﬁe-Hellman key exchange (DHKE) is a widely adopted method for exchanging cryptographic key material in realworld protocols like TLS-DH(E). Past attacks on TLS-DH(E) focused on weak parameter choices or missing parameter validation. The conﬁdentiality of the computed DH share, the premaster secret, was never questioned; DHKE is used as a generic method to avoid the security pitfalls of TLS-RSA.},
	language = {en},
	author = {Merget, Robert and Brinkmann, Marcus and Aviram, Nimrod and Somorovsky, Juraj and Mittmann, Johannes},
	year = {2019},
	pages = {19},
	file = {Merget et al. - Raccoon Attack Finding and Exploiting Most-Signiﬁ.pdf:/home/lucas/archive/Zotero/storage/VAMIRY4M/Merget et al. - Raccoon Attack Finding and Exploiting Most-Signiﬁ.pdf:application/pdf},
}

@article{hvass_high-assurance_nodate,
	title = {High-assurance ﬁeld inversion for curve-based cryptography},
	abstract = {Modern cryptography must satisfy a myriad of security properties, ranging from sound hardness assumptions to correct and secure implementations that resist side-channel cryptanalysis. Curve-based cryptography is not diﬀerent in this regard, and substantial progress in the last few decades has been achieved in both selecting parameters and devising secure implementation strategies. In this context, the security of implementations of ﬁeld inversion is sometimes overlooked in the research literature, because (i) the approach based on Fermat’s Little Theorem (FLT) suﬃces performance-wise for many parameters used in practice; (ii) it is typically invoked only at the very end of scalar multiplication or pairing computation, with a small impact in performance; (iii) it is challenging to implement securely for general parameters without a signiﬁcant performance penalty. However, ﬁeld inversion can process sensitive information and must be protected with side-channel countermeasures like any other cryptographic operation, as illustrated by recent attacks [ASS17, AGTB18, AGB20]. In this work, we focus on timing attacks against ﬁeld inversion for primes of cryptographic interest, both in the case when FLT-based inversion can be eﬃciently implemented or not. We extend the Fiat-Cryptography framework, which synthesizes provably correct-by-construction implementations, to implement the Bernstein-Yang constant-time inversion algorithm as a step toward this goal. This allows a correct implementation of prime ﬁeld inversion to be conveniently synthesized for any prime. We benchmark the implementations across a range of primes for curve-based cryptography and they outperform traditional FLT-based approaches in most cases, with observed speedups up to 2.5 for the largest parameters. Our work is already used in production in the MirageOS unikernel operating system1.},
	language = {en},
	author = {Hvass, Benjamin S and Aranha, Diego F and Spitters, Bas},
	pages = {23},
	file = {Hvass et al. - High-assurance ﬁeld inversion for curve-based cryp.pdf:/home/lucas/archive/Zotero/storage/JK5ET46R/Hvass et al. - High-assurance ﬁeld inversion for curve-based cryp.pdf:application/pdf},
}

@misc{wahby_hashing_nodate,
	title = {Hashing to {Elliptic} {Curves}},
	url = {https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-09},
	language = {en},
	urldate = {2021-05-01},
	author = {Wahby, Riad and Wood, Christopher and Faz-Hernández, Armando and Scott, Sam and Sullivan, Nick},
	file = {Snapshot:/home/lucas/archive/Zotero/storage/RAQQERH2/draft-irtf-cfrg-hash-to-curve-09.html:text/html},
}
