\documentclass[11pt, a4paper]{article} %\documentclass[11pt, a4paper, twoside, openright]{article} %draft

\usepackage{graphicx,color}
\usepackage{amssymb, amsmath, array}
\usepackage{hyperref}
\usepackage{newpxtext, newpxmath}


\begin{document}

\onecolumn

\input{cover}


\thispagestyle{empty}

\newpage

\tableofcontents{\protect\thispagestyle{empty}

\clearpage

\section{Introduction}

With the Internet cemented as a principal keystone in communication, and ever
increasing activity taking place digitially, the importance of secure
communication and Cryptography has never been greater. Thankfully, after
50 years of Public Key Cryptography
\cite{hellman_overview_1978},
we have good theoretical systems to provide these guarantees.

Most of these systems rely on modular arithmetic with large numbers,
such as RSA or Elliptic Curve Cryptography
\cite{rivest_method_1978, miller_use_1986}
.
Working with such numbers is not natively supported by hardware,
requiring a "Big Number" software library to provide this functionality.

Unfortunately, even though Public Key Cryptosystems have been heavily
scrutinized \textit{in theory}, in practice many vulnerabilities arise
in software implementations of these systems.

One particularly pernicious class of vulnerability are
\textbf{timing attacks}
\cite{kocher_cryptanalysis_1995}, where an implementation leaks information
about secret values through its execution time or cache usage, among
many side-channels.

Libraries for Big Numbers that are not designed with Cryptography in mind
are pervasively vulnerable to this class of attack.

In particular, Go \cite{the_go_authors_go_nodate} provides a general purpose
Big Number type, \texttt{big.Int}, which suffers from these vulnerabilities,
as we detail later in this report. Unfortunately, this library
gets used for Cryptography
\cite{ford_proposal_2017}, including inside of Go's own standard library,
in \texttt{go/crypto}.

We've addressed this issue by creating a library
\cite{meier_cronokirbysafenum_2021}
designed to work with Big Numbers in the context of Public Key Cryptography.
Our library provides the necessary operations for implementing these systems,
all while avoiding the leakage of secret information.
To demonstrate its utility, we've modified Go's \texttt{go/crypto}
package, replacing the use of \texttt{big.Int} in the DSA and RSA
systems.

\section{Background}

In this section, we explain how Big Numbers are used in Public Key
Cryptography, what timing attacks are, and how they affect our threat
model, as well as what kind of side-channels are present in Go's
\texttt{big.Int} type.

\subsection{Big Numbers in Cryptography}

As mentioned previously, most Public Key Cryptosystems rely on
modular arithmetic.

In RSA \cite{rivest_method_1978}, for example, a public key $(e, N)$ consists of modulus
$N \in \mathbb{N}$, usually 2048 bits long, and an exponent taken
modulo $\varphi(N)$.
To encrypt a message $m \in \mathbb{Z}/N\mathbb{Z}$, we calculate

$$
c := m^e \mod N
$$

The typical word size on computers is now 64 bits. Because of this,
to do arithmetic modulo $N$, we need a Big Number library to work
with these large numbers, as well as to provide optimized implementations
of opereaitons like modular exponentiation, which aren't natively supported.

DSA
\cite{technology_digital_1994} also relies on modular arithmetic,
this time using a large prime $p$ of around 2048 bits, and working
in the multiplicative group $(\mathbb{Z}/p\mathbb{Z})^*$.

Elliptic Curve Cryptography
\cite{miller_use_1986} relies on complex formulas for adding points
on an elliptic curve, built over a finite field $K$. This field
is usually either a prime field $\mathbb{Z}/p\mathbb{Z}$, in which case arithmetic
modulo $p$ is used, or a
binary extension field $\text{GF}(2^n)$, in which case
binary arithmetic in combination with polynomial addition and multiplication
are used.

For prime fields, a Big Number library is once again necessary, because
the size of the prime is greater than 200 bits.

In summary, large modular arithmetic is a cornerstone of Public Key
cryptosystems, requiring Big Numbers in some form.

\subsubsection{Big Numbers in \texttt{go/crypto}}

Go \cite{the_go_authors_go_nodate} provides implementations of numerous
cryptographic algorithms as part of its standard library,
including the aforementioned Public Key systems, in the
\texttt{go/crypto} package.

Unfortunately \cite{ford_proposal_2017}, the general purpose
\texttt{big.Int} type gets used in this package for Cryptography,
despite its potential vulnerability to timing attacks.

For DSA \cite{technology_digital_1994}, Go uses \texttt{big.Int}
for all operations, including key generation, signing, and verification.

For RSA \cite{rivest_method_1978}, Go uses \texttt{big.Int}
for all operations, and fixes this type as part of the API for
this package. Key generation, encryption, decryption, signing,
and verification all use \texttt{big.Int}.

For ECC \cite{miller_use_1986}, Go defines a general interface
for Elliptic Curves, requiring operations like point addition,
scalar multiplication, etc. All of these are defined in terms
of \texttt{big.Int}. Some of the curves have specialized
implementations of their prime field, only converting from
\texttt{big.Int} to satisfy the interface curves. The remaining curves
directly make use \texttt{big.Int} for their field arithmetic.

\subsection{Timing Attacks}

A side-channel
\cite{kelsey_side_1998}
leaks secret information about a program not directly,
but indirectly, through the observable properties of its execution.
For example, timing side-channels use the execution time of a program
to infer properties of the secret data it processes. 
A timing attack is the use of a timing side-channel to break the security
of some program or cryptographic protocol.

If a program takes a different number of steps based on the value of some
secret, then this constitutes an obvious timing side-channel.
For example, if a naive program for comparing inputs with a secret password
stops as soon as a mismatch is found, then the algorithm itself has
a timing side-channel. This side-channel can be exploited, to allow
the secret password to be guessed byte by byte.

Not all timing side-channels are this simple, however. Algorithms
that take the same number of steps regardless of the value of secret
data can still having timing side-channels because of how the underlying
hardware executing the program works. For example, a processor may
execute an operation faster for some inputs, or the presence of a cache
could be used to infer what addresses are being accessed. These
microarchitectural timing side-channels are also of concern.
See \cite{ge_survey_2018} for a survey of these vulnerabilities.

\subsubsection{Actual Attacks}

Explain how these concerns actually lead to vulnerabilities in systems.

\subsubsection{Our Threat-Model}

Explain the threat model we have, and what side-channels we aren't concerned
about.

\subsection{Vulnerabilities in \texttt{big.Int}}

Explain what vulnerabilities are potentially lurking in bigInt.

\subsubsection{Padding and Truncation}

Explain how big.Int truncates numbers internally.

Explain potential issues with padding in cryptography.

\subsubsection{Leaky Algorithms}

Explain how most algorithms are potentially leaky.

\subsubsection{Mitigations}

Explain what mitigations are deployed in Go.

\section{Implementation}

Describe at a high level what we've done.

\subsection{Strategies for numbers in Cryptography}

Describe different strategies in place for providing numbers for
Cryptography.

\subsection{The \texttt{safenum} library}

Describe at a high level what the library provides.

\subsubsection{Handling Size}

Describe how we handle sizing of numbers.

\subsection{Some Basic Techniques}

Describe some basic techniques for constant-time operation.

\subsection{Some Algorithm Choices}

Describe the algorithm choices we've used for different things.

\section{Results}

Describe what results we've managed to perform.

\subsection{Comparison with \texttt{big.Int}}

Describe the final performance results we've managed to achieve.

\subsection{Comparison with \texttt{go/crypto}}

Describe the benchmarks on actual code.

\section{Further Work}

\subsection{Upstreaming to \texttt{go/crypto}}

Describe our work in providing a patch for RSA, and what results we've
managed to achieve.

\section{Conclusion}

Summarize the things we put in the introduction.

\section*{Acknowledgements}
\addcontentsline{toc}{section}{Acknowledgements}

\bibliographystyle{plainurl}
\bibliography{references}
\end{document}
