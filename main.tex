\documentclass[11pt, a4paper]{article} %\documentclass[11pt, a4paper, twoside, openright]{article} %draft

\usepackage{graphicx,color}
\usepackage{amssymb, amsmath, array}
\usepackage{hyperref}
\usepackage{newpxtext, newpxmath}


\begin{document}

\onecolumn

\input{cover}


\thispagestyle{empty}

\newpage

\tableofcontents{\protect\thispagestyle{empty}

\clearpage

\section{Introduction}

With the Internet cemented as a principal keystone in communication, and ever
increasing activity taking place digitially, the importance of secure
communication and Cryptography has never been greater. Thankfully, after
50 years of Public Key Cryptography
\cite{hellman_overview_1978},
we have good theoretical systems to provide these guarantees.

Most of these systems rely on modular arithmetic with large numbers,
such as RSA or Elliptic Curve Cryptography
\cite{rivest_method_1978, miller_use_1986}
.
Working with such numbers is not natively supported by hardware,
requiring a "Big Number" software library to provide this functionality.

Unfortunately, even though Public Key Cryptosystems have been heavily
scrutinized \textit{in theory}, in practice many vulnerabilities arise
in software implementations of these systems.

One particularly pernicious class of vulnerability are
\textbf{timing attacks}
\cite{kocher_cryptanalysis_1995}, where an implementation leaks information
about secret values through its execution time or cache usage, among
many side-channels.

Libraries for Big Numbers that are not designed with Cryptography in mind
are pervasively vulnerable to this class of attack.

In particular, Go \cite{the_go_authors_go_nodate} provides a general purpose
Big Number type, \texttt{big.Int}, which suffers from these vulnerabilities,
as we detail later in this report. Unfortunately, this library
gets used for Cryptography
\cite{ford_proposal_2017}, including inside of Go's own standard library,
in \texttt{go/crypto}.

We've addressed this issue by creating a library
\cite{meier_cronokirbysafenum_2021}
designed to work with Big Numbers in the context of Public Key Cryptography.
Our library provides the necessary operations for implementing these systems,
all while avoiding the leakage of secret information.
To demonstrate its utility, we've modified Go's \texttt{go/crypto}
package, replacing the use of \texttt{big.Int} in the DSA and RSA
systems.

\section{Background}

In this section, we explain how Big Numbers are used in Public Key
Cryptography, what timing attacks are, and how they affect our threat
model, as well as what kind of side-channels are present in Go's
\texttt{big.Int} type.

\subsection{Big Numbers in Cryptography}

As mentioned previously, most Public Key Cryptosystems rely on
modular arithmetic.

In RSA \cite{rivest_method_1978}, for example, a public key $(e, N)$ consists of modulus
$N \in \mathbb{N}$, usually 2048 bits long, and an exponent taken
modulo $\varphi(N)$.
To encrypt a message $m \in \mathbb{Z}/N\mathbb{Z}$, we calculate

$$
c := m^e \mod N
$$

The typical word size on computers is now 64 bits. Because of this,
to do arithmetic modulo $N$, we need a Big Number library to work
with these large numbers, as well as to provide optimized implementations
of opereaitons like modular exponentiation, which aren't natively supported.

DSA
\cite{technology_digital_1994} also relies on modular arithmetic,
this time using a large prime $p$ of around 2048 bits, and working
in the multiplicative group $(\mathbb{Z}/p\mathbb{Z})^*$.

Elliptic Curve Cryptography
\cite{miller_use_1986} relies on complex formulas for adding points
on an elliptic curve, built over a finite field $K$. This field
is usually either a prime field $\mathbb{Z}/p\mathbb{Z}$, in which case arithmetic
modulo $p$ is used, or a
binary extension field $\text{GF}(2^n)$, in which case
binary arithmetic in combination with polynomial addition and multiplication
are used.

For prime fields, a Big Number library is once again necessary, because
the size of the prime is greater than 200 bits.

In summary, large modular arithmetic is a cornerstone of Public Key
cryptosystems, requiring Big Numbers in some form.

\subsubsection{Implementing Big Numbers}

Describe different strategies in place for providing numbers for
Cryptography.

\subsubsection{Big Numbers in \texttt{go/crypto}}

Go \cite{the_go_authors_go_nodate} provides implementations of numerous
cryptographic algorithms as part of its standard library,
including the aforementioned Public Key systems, in the
\texttt{go/crypto} package.

Unfortunately \cite{ford_proposal_2017}, the general purpose
\texttt{big.Int} type gets used in this package for Cryptography,
despite its potential vulnerability to timing attacks.

For DSA \cite{technology_digital_1994}, Go uses \texttt{big.Int}
for all operations, including key generation, signing, and verification.

For RSA \cite{rivest_method_1978}, Go uses \texttt{big.Int}
for all operations, and fixes this type as part of the API for
this package. Key generation, encryption, decryption, signing,
and verification all use \texttt{big.Int}.

For ECC \cite{miller_use_1986}, Go defines a general interface
for Elliptic Curves, requiring operations like point addition,
scalar multiplication, etc. All of these are defined in terms
of \texttt{big.Int}. Some of the curves have specialized
implementations of their prime field, only converting from
\texttt{big.Int} to satisfy the interface curves. The remaining curves
directly make use \texttt{big.Int} for their field arithmetic.

\subsection{Timing Attacks}

A side-channel
\cite{kelsey_side_1998}
leaks secret information about a program not directly,
but indirectly, through the observable properties of its execution.
For example, timing side-channels use the execution time of a program
to infer properties of the secret data it processes. 
A timing attack is the use of a timing side-channel to break the security
of some program or cryptographic protocol.

If a program takes a different number of steps based on the value of some
secret, then this constitutes an obvious timing side-channel.
For example, if a naive program for comparing inputs with a secret password
stops as soon as a mismatch is found, then the algorithm itself has
a timing side-channel. This side-channel can be exploited, to allow
the secret password to be guessed byte by byte.

Not all timing side-channels are this simple, however. Algorithms
that take the same number of steps regardless of the value of secret
data can still having timing side-channels because of how the underlying
hardware executing the program works. For example, a processor may
execute an operation faster for some inputs, or the presence of a cache
could be used to infer what addresses are being accessed. These
microarchitectural timing side-channels are also of concern.
See \cite{ge_survey_2018} for a survey of these vulnerabilities.

\subsubsection{Actual Attacks}

The presence of a side-channel does not directly lead to vulnerabilities.
As early as 1995, Paul Kocher
demonstrated the potential for timing attacks against cryptographic
algorithms \cite{kocher_cryptanalysis_1995, kocher_timing_1996}.
These specific attacks rely on algorithms that perform a varying number of
operations based on secret data. 

One common objection to timing attacks more generally is that they
while a timing side-channel is catastrophic in theory, in practice
this channel is too noisy to exploit. Unfortunately, through gathering
many samples, it's possible to exploit these attacks even across
a network \cite{brumley_remote_2005, brumley_remote_2011}.

The use of caches as a potential side-channel was
identified early on as well \cite{page_theoretical_2002}.
The idea is that accessing data that is not present in the cache
takes longer than accessing data inside of the cache. If what data
is being accessed depends on a secret value, the observed execution
time will thus also depend on this secret value. If an attacker is located
on the same machine they can place data into the cache as well, and probe
the cache themselves, to learn fine-grained information about the
program's access patterns. While seemingly far-fetched, this is easy
to achieve now that so many applications are run on cloud computing.

A wide variety of attacks involving caches have been mounted
against various cryptosystems
\cite{
  bernstein_cache-timing_2005,
  yarom_cachebleed_2017,
  cabrera_aldaya_cache-timing_2019}
, making accessing data based on secret
values fraught with peril.

\subsubsection{Our Threat-Model}
\label{threat_model}

Although the variety of potential timing side-channels is quite daunting,
we can distill them into a simple, albeit pessimistic set of rules:

\begin{enumerate}
  \item Any loop leaks the number of iterations taken.
  \item Any memory access leaks the address accessed.
  \begin{enumerate}
    \item As a consequence, accessing an array leaks the index accessed.
  \end{enumerate}
  \item Any conditional statement leaks which branch was taken.
\end{enumerate}

Rule 1 is justified by theoretical concerns, since a longer loop
requires more operations. In practice, it's difficult to observe
the iterations of each loop in a program from an overall timing signal,
making this a pessimistic rule.

Rule 2 is justified by various cache based side-channels and attacks
\cite{
  bernstein_cache-timing_2005,
  yarom_cachebleed_2017,
  cabrera_aldaya_cache-timing_2019}.
Since caches only load information an entire line at a time, it might
seem that our rule is too pessimistic, and that only which cache line
was accessed should be kept secret \cite{brickell_technologies_2011}.
Unfortunately, the potential for attacks on much finer grained
level has been demonstrated
\cite{
  bernstein_word_2013,
  osvik_cache_2006,
  yarom_cachebleed_2017}.
Because of these concerns, we take a pessimistic position, and assume
that accessing an array leaks the exact index accessed.


Rule 3 is justified in two ways. First, if different branches of a conditional
statement execute a different number of operations, this leaks information
about which branch was taken in a fundamental way. Second, even if both
branches execute identitical operations, the CPU's branch predictor
can be exploited, leaking information about which branch was taken
\cite{
  aciicmez_predicting_2006,
  aciicmez_power_2007,
  evtyushkin_jump_2016}.

In addition to these rules, we assume that addition, multiplication,
logical operations, and shifts, as implemented in hardware,
are constant-time in their inputs.
This is the case on most processors, one notable exception being
microprocessors
\cite{pornin_bearssl_nodate}. For the platforms which Go,
and thus our library, targets,
this assumption is reasonable.

\subsection{Vulnerabilities in \texttt{big.Int}}

Go provides a general purpose type for Big Numbers: \texttt{big.Int}.
This implementation is concerned with being broadly applicable,
and well-optimized. It does not focus on security, or on hardening
itself against timing side-channels.

Unfortunately, its broad applicability makes it useful for cryptography,
and it gets used throughout Go's standard cryptography library,
as we've seen previously.

In this section, we look at some of the important implementation aspects
of \texttt{big.Int}, and how they might be potentially vulnerable
according to our threat model.

\subsubsection{Padding}

The \texttt{big.Int} type always normalizes numbers internally,
removing any leading zero limbs. Even if you initialize a number
using bytes zero-padded to a certain length, the resulting value
will immediately chop off these zeros. These extra zeros don't
change the value of a number. By discarding them, operations on
this number will have fewer limbs to process, and will be faster.

Unfortunatelly, this means that \texttt{big.Int} leaks information
about the padding of numbers pervasively. Since every operation on
a number takes more time the more limbs the number uses,
the removal of padding leaks the true sizes of numbers
at every operation.
Leaking this padding has been exploited
in OpenSSL \cite{merget_raccoon_2019}, and might potentially
be a vulnerability in Go's cryptography library, because of \texttt{big.Int}.

\subsubsection{Leaky Algorithms}

Because \texttt{big.Int} is not written with Cryptography in mind,
its methods violate the rules set in
\ref{threat_model}. Many methods take a different number of iterations
based on their values, branch conditionally on values, and
access memory depending on values. Because \texttt{big.Int}
is designed for general purpose use, this problem should only get worse
as the library is further developed and optimized.

Ultimately, the problem is not the existence of \texttt{big.Int},
but it's use in Go's cryptography library, and in the broader ecosystem.

\subsubsection{Mitigations}

Although \texttt{big.Int} gets used in Go's cryptography library,
the authors are aware of its shortcomings, and have implemented
several mitigations to try and make its timing side-channels harder to
exploit.

One of the most important ones is a mitigation
for RSA: blinding \cite{kocher_timing_1996}. The decrypt a ciphertext
$c = m^e \mod N$, we normally calculate:

$$
c^d \mod N
$$

with $d$ our private key, and $(e, N)$ our public key.
When exponentiation is not implemented in a constant-time way, like
with \texttt{big.Int}, this process can leak information about $m$.
If an adversary can choose $c$, then this can leak information about
$d$ as well.

To mitigate this, instead of decrypting $c$ directly,
we first generate a random integer
$r \in [0, N - 1]$, and make sure
it has an inverse $r^{-1}$ mod $N$. Then we decrypt $r^e \cdot c$.
This gives us the value $r \cdot m$, and we can recover
$m$ by multiplying by $r^{-1}$.

While this does effectively mitigate the simplest attacks
against exponentiation, a very leaky operation, the other operations
involving these values are still left unprotected, and may
have exploitable leakages in more subtle ways. We also have
the unaddressed issue of padding, which has lead to attacks
in OpenSSL \cite{merget_raccoon_2019}.

\section{Implementation}

We've implemented a library, called
\texttt{safenum} \cite{meier_cronokirbysafenum_2021}, intended to provide
a replacement for \texttt{big.Int}, suitable for use in Cryptography.
In order to demonstrate its utility, we've replaced some
of \texttt{go/crypto}'s usage of \texttt{big.Int} with our own library,
in a separate repository
\cite{meier_cronokirbyctcrypto_2021}.

In this section, we go over the design and implementation of our
library.

\subsection{The \texttt{safenum} library}

Describe at a high level what the library provides.

\subsubsection{Handling Size}

Describe how we handle sizing of numbers.

\subsubsection{Moduli}

Describe how moduli are handled

\subsection{Limbs}

\subsection{Constant-Time Operations}

Describe some basic techniques for constant-time operation.

\subsection{Algorithm Choices}

Describe the algorithm choices we've used for different things.

\section{Results}

Describe what results we've managed to perform.

\subsection{Comparison with \texttt{big.Int}}

Describe the final performance results we've managed to achieve.

\subsection{Comparison with \texttt{go/crypto}}

Describe the benchmarks on actual code.

\section{Further Work}

\subsection{Upstreaming to \texttt{go/crypto}}

Describe our work in providing a patch for RSA, and what results we've
managed to achieve.

\section{Conclusion}

Summarize the things we put in the introduction.

\section*{Acknowledgements}
\addcontentsline{toc}{section}{Acknowledgements}

\bibliographystyle{plainurl}
\bibliography{references}
\end{document}
